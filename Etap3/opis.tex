\documentclass{article}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{lmodern}
\usepackage[margin=0.75in]{geometry}
\usepackage{float}
\usepackage[export]{adjustbox}
\usepackage{xcolor}
\usepackage{sectsty}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{hyperref}
\titlelabel{\thetitle.\quad}
\definecolor{Myblue}{rgb}{0.14,0.4,0.74}
\definecolor{Myblue2}{rgb}{0.14,0.6,0.84}
\sectionfont{\color{Myblue}}
\subsectionfont{\color{Myblue2}}
\definecolor{codepurple}{HTML}{C42043}

\renewcommand{\lstlistingname}{Kod}

\begin{document}
\begin{titlepage}
   \vspace*{80mm}
   \centering
   \noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
   \LARGE{\textsc{Temat nr 5 - Magazyn części zamiennych}\\}
   Bazy Danych\\
   \textsc{\large Dr hab. inż. Grzegorz Mzyk\\}
   \large \today \\
   \noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
   \begin{minipage}[l]{0.3\textwidth}
      \vspace{0.4cm}
      Autorzy:\\
      \textsc{\large Emilia Starczyk} 249005\\
      \textsc{\large Michał Kaleta} 248976\\
   \end{minipage}

   \vfill
\end{titlepage}
\section{Cel projektu}
\paragraph{}
Celem projektu jest stworzenie aplikacji pozwalającej na składanie zamówień
przez użytkownika. Administrator/właściciel może przeglądać części zamienne do
danego produktu oraz może zamówić poszczególne części.
\section{Założenia projektowe}
\paragraph{}
Projekt zostanie wykonany przy użyciu technologi dostępnych w ramach frameworku
ASP.NET w języku C\#. Jako baza danych posłuży nam serwer Oracle Database XE 18C.
\section{Tabele}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth,frame]{diagram.png}
   \caption{Projekt koncepcyjny bazy danych}
\end{figure}
\subsection{Tabela produktów}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Products}             \\ \hline
   PK & product\_id   & int NOT NULL          \\ \hline
      & product\_name & varchar(200) NOT NULL \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela przechowuje wszystkie produkty możliwe do zamówienia. Każdy produkt ma
swój unikalny ID.

\subsection{Tabela faktur}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Invoices}             \\ \hline
   PK & invoice\_id   & int NOT NULL          \\ \hline
      & invoice\_date & varchar(200) NOT NULL \\
      & purchaser     & varchar(200) NOT NULL \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela zawiera informacje o tym, kiedy zostało złożone zamówienie.
Kolumna purchaser zawiera informacje o nazwie podmiotu, który złożył zamówienie
- może być to firma lub osoba fizyczna. Dodanie faktury do tabeli powoduje
dodanie produktów zamówionych w ramach tej faktury do tabeli Invoice\_Items.

\subsection{Tabela pozycji na fakturach}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Invoice\_Items}  \\ \hline
   FK & invoice\_id       & int NOT NULL \\ \hline
   FK & product\_id       & int NOT NULL \\
      & product\_quantity & int NOT NULL \\
   PK & key               & int NOT NULL \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela zawiera informacje o tym, jakie produkty \textit{product\_id} i jaka ich
ilość \textit{product\_quantity} została zamówiona w ramach danej faktury \textit{invoice\_id}.
Ze względu na użytą technologię wymagane było dodanie klucza głównego do tej tabelii.
\subsection{Tabela części}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Details}                    \\ \hline
   PK & detail\_id   & int NOT NULL UNIQUE          \\ \hline
      & detail\_name & varchar(200) NOT NULL UNIQUE \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela przechowuje wszytskie możliwe detale potrzebne w firmie.

\subsection{Tabela stanu magazynowego}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Stock}                         \\ \hline
   PK,FK & detail\_id   & int NOT NULL UNIQUE          \\ \hline
         & detail\_name & varchar(200) NOT NULL UNIQUE \\
         & quantity     & int NOT NULL                 \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela zawiera informacje o stanie magazynowym. Jeśli dany detal detail\_id,
jest dostępny na magazynie, to istnieje on w tej tabeli wraz z liczbą dostępnych
elementów. Jeśli jego liczba została zredukowana do 0 poprzez produkcję, zostaje
on automatycznie usunięty z magazynu.
\newpage
\subsection{Tabela specyfikacji produktu}
\begin{tabular}{|c|l|l|} \hline
   \multicolumn{3}{|c|}{Prod\_Specification} \\ \hline
   PK,FK & detail\_id       & int NOT NULL   \\ \hline
   FK    & product\_id      & int NOT NULL   \\
         & detail\_quantity & int NOT NULL   \\ \hline
\end{tabular} \\
\vspace{0.3cm} \\
Tabela przechowuje detale potrzebne do stworzenia produktu. Jeśli produkt ma
więcej niż jedną część, to tabela zawiera więcej rzędów o takim samym product\_id.
\section{Relacje między tabelami}
\begin{enumerate}
   \item Tabela Invoice\_Items zawiera kolumnę invoice\_id z tabeli Invoices.
         Relacja między tabelami to 1:N, ponieważ jedna faktura z tabeli
         Invoices może mieć jeden lub więcej odnośników w tabeli Invoice\_Items.
   \item Tabela Invoice\_Items zawiera w sobie również kolumnę product\_id z
         tabeli Products. Relacja pomiędzy tymi tabelami to również relacja jeden do
         wielu, ponieważ w wielu fakturach produkty mogą się powtarzać. Zatem Tabela
         Invoice\_Items może zawierać jeden lub więcej odnośników do jednego wiersza w
         tabeli Products.
   \item Tabela Prod\_Specification zawiera w sobie kolumnę product\_id z tabeli
         Products. Tutaj również zastosowana jest relacja 1:N, ponieważ jeden
         produkt może mieć jeden lub więcej elementów.
   \item Dodatkowo tabela Prod\_Specification zawiera kolumnę detail\_id z
         tabeli Details. Relacja pomiędzy tymi tabelami to 1:N, ponieważ w
         specyfikacji produktów będzie wielokrotnie występował dany element.
   \item Tabela Stock zawiera kolumnę detail\_id z tabeli Details. Relacja
         pomiędzy tymi tabelami to jeden do jednego, ponieważ jeden wiersz w tabeli
         stock będzie odpowiadał jednemu wierszowi z tabeli Details.
\end{enumerate}

\section{Funkcjonalności oraz prawa dostępu poszczególnych grup użytkowników}
\begin{enumerate}
   \item Grupa Zamawiających
         \begin{itemize}
            \item Wgląd w listę dostępnych produktów.
            \item Składanie zamówienia na dane produkty.
         \end{itemize}
   \item Grupa administratorów
         \begin{itemize}
            \item Wgląd w listę dostępnych produktów.
            \item Podgląd stanów magazynowych.
            \item Podgląd złożonych zamówień.
            \item Automatyczne zamawianie części do magazynu, jeśli w złożonym
                  zamówieniu są produkty, do których brakuje elementów.
            \item Podgląd specyfikacji produktów.
         \end{itemize}
   \item Inne funkcjonalności:
         \begin{itemize}
            \item Stany magazynowe są automatycznie aktualizowane po złożeniu
                  zamówienia przez Zamawiającego.
            \item Automatyczne zamawianie części do magazynu, jeśli w złożonym
                  zamówieniu są produkty, do których brakuje elementów.
         \end{itemize}
\end{enumerate}
\newpage
\section{Początek prac nad aplikacją}
\paragraph{}
Pracę nad aplikacją rozpoczeliśmy od przemyślenia funkcjonalności aplikacji.
Nastęnie przeszliśmy do zaprojektowania tabel i połączeń między
nimi, co zostało zaprezentowane w punktach 3 oraz 4. Kolejnym krokiem było
zapoznanie się z narzędziem pracy od firmy Oracle oraz składnią języka SQL.
\subsection{Tworzenie bazy danych oraz tabel}
Stworzenie bazy danych odbywa się poprzez wydanie komendy \textit{CREATE
   DATABASE nazwa\_bazy\_danych}. Tworzenie tabel w języku SQL odbywa się poprzez korzystanie z komendy
\textit{CREATE TABLE nazwa\_tabeli}. Poszczególne kolumny tabeli wymiania się po
otworzeniu nawiasów. Należy określić rodzaj danych w poszczególnych kolumnach
oraz klucze tabeli. Dodatkowo można określić ograniczenia dla poszczególnych
kolumn tabeli.

Poniżej znajdują się komendy potrzebne do stworzenia poszczególnych tabel
wraz z komendami użytymi do stworzenia wyzwalaczy ustawiających klucz
główny każdego kolejego rzędu o jeden większy od poprzedniego. Zostały do
tego użyte sekwencje zaprezentowane w kolejnym punkcie.
\subsubsection{Tworzenie tabeli faktur}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE TABLE INVOICES 
   (	INVOICE_ID NUMBER NOT NULL , 
	INVOICE_DATE DATE NOT NULL , 
	PURCHASER NVARCHAR2(200) NOT NULL , 
	 CONSTRAINT INVOICES_PK PRIMARY KEY (INVOICE_ID)
   ) 
\end{lstlisting}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE OR REPLACE TRIGGER INVOICES_TRIGGER1 
BEFORE INSERT ON INVOICES
FOR EACH ROW
BEGIN
	SELECT INVOICE_ID_SEQUENCE.NEXTVAL
	INTO :NEW.INVOICE_ID
	FROM DUAL;
END;
/
\end{lstlisting}

\subsubsection{Tworzenie tabeli produktów zamówionych w ramach faktur}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE TABLE INVOICE_ITEMS 
   (	INVOICE_ID NUMBER NOT NULL , 
	PRODUCT_ID NUMBER NOT NULL , 
	PRODUCT_QUANTITY NUMBER NOT NULL , 
	KEY NUMBER NOT NULL , 
	 CONSTRAINT INVOICE_ITEMS_PK PRIMARY KEY (KEY),
	 CONSTRAINT INVOICE_FK FOREIGN KEY (INVOICE_ID)
	  REFERENCES INVOICES (INVOICE_ID) , 
	 CONSTRAINT PRODUCT_FK FOREIGN KEY (PRODUCT_ID)
	  REFERENCES PRODUCTS (PRODUCT_ID) 
   )
\end{lstlisting}
\newpage
\begin{lstlisting}[language=SQL,frame=single]
  CREATE OR REPLACE TRIGGER INVOICE_ITEMS_TRIGGER1 
BEFORE INSERT ON INVOICE_ITEMS
FOR EACH ROW
BEGIN
	SELECT INVOICE_ITEM_SEQUENCE.NEXTVAL
	INTO :NEW.KEY
	FROM DUAL;
END;
/
\end{lstlisting}

\subsubsection{Tworzenie tabeli produktów}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE TABLE PRODUCTS 
   (	PRODUCT_ID NUMBER NOT NULL , 
	PRODUCT_NAME NVARCHAR2(200) NOT NULL , 
	 CONSTRAINT PRODUCTS_PK PRIMARY KEY (PRODUCT_ID)
   )
\end{lstlisting}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE OR REPLACETRIGGER PRODUCTS_TRIGGER1 
BEFORE INSERT ON PRODUCTS
FOR EACH ROW
BEGIN
	SELECT PRODUCT_ID_SEQUENCE.NEXTVAL
	INTO :NEW.PRODUCT_ID
	FROM DUAL;
END;
/
\end{lstlisting}

\subsubsection{Tworzenie tabeli części}
\begin{lstlisting}[language=SQL,frame=single]
   CREATE TABLE DETAILS 
   (	DETAIL_ID NUMBER NOT NULL , 
	DETAIL_NAME NVARCHAR2(200) NOT NULL , 
	 CONSTRAINT DETAILS_PK PRIMARY KEY (DETAIL_ID)
   )
\end{lstlisting}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE OR REPLACE TRIGGER DETAILS_TRIGGER1 
  BEFORE INSERT ON DETAILS
FOR EACH ROW
BEGIN
	SELECT DETAIL_ID_SEQUENCE.NEXTVAL
	INTO :NEW.DETAIL_ID
	FROM DUAL;
END;
/
\end{lstlisting}

\newpage
\subsubsection{Tworzenie tabeli specyfikacji produktów}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE TABLE PROD_SPECIFICATION 
   (	DETAIL_ID NUMBER NOT NULL , 
	PRODUCT_ID NUMBER NOT NULL , 
	DETAIL_QUANTITY NUMBER NOT NULL , 
	 CONSTRAINT SPEC_PROD_FK FOREIGN KEY (PRODUCT_ID)
	  REFERENCES PRODUCTS (PRODUCT_ID) , 
	 CONSTRAINT SPEC_DETAIL_FK FOREIGN KEY (DETAIL_ID)
	  REFERENCES DETAILS (DETAIL_ID) 
   ) 
\end{lstlisting}

\subsubsection{Tworzenie tabeli magazynu}
\begin{lstlisting}[language=SQL,frame=single]
  CREATE TABLE STOCK 
   (	DETAIL_ID NUMBER NOT NULL , 
	DETAIL_NAME NVARCHAR2(200) NOT NULL , 
	QUANTITY NUMBER NOT NULL , 
	 CONSTRAINT STOCK_PK PRIMARY KEY (DETAIL_ID), 
	 CONSTRAINT STOCK_DETAIL_FK FOREIGN KEY (DETAIL_ID)
	  REFERENCES DETAILS (DETAIL_ID)
\end{lstlisting}

\subsection{Tworzenie sekwencji}

Użycie sekwencji zapewnia nam unikalność klucza głównego, który będzie zaczynał
się od wartości 1 i zwiększał się z każdym kolejnym rzędem o 1. Stworzyliśmy 4
sekwencje, które zostały użyte w wyzwalaczach w poszczególnych tabelach.

\begin{lstlisting}[language=SQL,frame=single]
   CREATE SEQUENCE  DETAIL_ID_SEQUENCE 
   START WITH 1
   INCREMENT BY 1
   NOCACHE
   NOCYCLE;
 \end{lstlisting}

\subsection{Dodawanie danych do tabeli}
Dodawanie danych do tabeli odbywa się poprzez korzystanie z komendy
\textit{INSERT INTO nazwa\_tabeli (kolumna1, kolumna2) VALUES
   (wartość1, wartość2)}. Komenda ta nie musi zawierać wypisanych nazw kolumn, pod
warunkiem, że wpychamy do tabeli całe wiersze danych.
Poniżej przedstawione jest przykładowe dodanie produktu do tabeli Products.

\begin{lstlisting}[language=SQL,frame=single]
INSERT INTO Products (product_name) VALUES ('odkurzacz');
 \end{lstlisting}

\section{Implementacja}
\paragraph{}
Pracę nad implementacją rozpoczęliśmy od połączenia aplikacji z naszą bazą danych.
Skorzystaliśmy z mapowania bazy danych do przestrzeni obiektowej za pomocą Entity Framework, by móc odnosić
się do poszczególnych elementów z pozycji programu.
W kolejnym kroku zaczęliśmy pracę nad implementowaniem założonych funkcjonalności systemu.
Rozpoczęliśmy od możliwości zamawiania produktów, ponieważ potrzebna ona była do pozostałych
funkcjonalności. Początkowo system zamawiania polegał na wybraniu produktu z rozwijanej listy i
wpisaniu ilości produktu, jaką chcemy zamówić. Okno wpisywania zostało zabezpieczone zgodnie z
zasadami walidacji danych.
Następnym krokiem było utworzenie strony wyświetlającej potwierdzenie zamówienia oraz strony
wyświetlającej części potrzebne do produkcji danego przedmiotu. W tym kroku stworzyliśmy również
podział na widoki: widok administratora oraz widok zwykłego użytkownika. Strona wyświetlająca części
zamienne została przypisana do widoku administratora, zaś strona z potwierdzeniem została przypisana do
widoku zwykłego użytkownika. Następnie dodaliśmy przeglądanie części znajdujących się w magazynie
oraz dodaliśmy możliwość przeglądania zamówień, realizacji zamówień oraz kasowania zamówień.
W kolejnym kroku zaimplementowaliśmy widok logowania do panelu administratora. Do panelu administratora
dodaliśmy również możliwość ręcznego zamawiania części do magazynu. Administrator uzyskał również
możliwość podglądu szczegółów dotyczących faktur oraz części potrzebnych do konkretnego zamówienia.
Po pierwszych testach wprowadziliśmy zmiany w panelu użytkownika. Zamiast zamawiania produktów z
rozwijanej listy wprowadziliśmy przeglądanie produktów kolejnymi stronami. Do produktów dodaliśmy
zdjęcia oraz przycisk dodawania do koszyka wraz z konkretną ilością. W pasku nawigacyjnym
umieściliśmy koszyk. Zaimplementowaliśmy dla niego osobną stronę prezentującą zawartość koszyka oraz
zajmującą się ostatecznym składaniem zamówienia. Po konsulatcji, wprowadziliśmy dodatkową tabelę w
bazie danych. Tabela służy do przechowywania historii zamówień.
Poniżej przedstawiona jest ostateczna struktura bazy danych znajdującej się w naszym projekcie.
\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth,frame]{diagram_f.png}
   \caption{Struktura bazy danych}
\end{figure}
\begin{figure}[H]
   \centering
   \begin{tabular}{|c|l|l|} \hline
      \multicolumn{3}{|c|}{Historical\_Invoices} \\ \hline
      PK & invoice\_id   & int NOT NULL          \\ \hline
         & invoice\_date & varchar(200) NOT NULL \\
         & purchaser     & varchar(200) NOT NULL \\ \hline
   \end{tabular} \\
\end{figure}
\vspace{0.3cm}
Tabela zawiera informacje o tym, kiedy było złożone zamówienie.
Kolumna purchaser zawiera informacje o nazwie podmiotu, który złożył zamówienie
- może być to firma lub osoba fizyczna. Kolumna z numerem id faktury (invoice\_id) pozwoliła nam na
dostanie informacji o szczegółach historycznego zamówienia potrzebnych do implementacji funkcji
automatycznego zamawiania na podstawie historii z ostatniego miesiąca. Oprócz dodania tabeli
historycznej dodaliśmy również kolumnę w tabeli ``Invoice\_Items''. Służy ona do przypisania pozycji
produktu na fakturze. Kolejnym krokiem była implementacja systemu automatycznego zamawiania. Funkcja ta jest oparta na przeszukiwaniu tabeli
historycznej w celu uzyskania zamówień z ostatniego miesiąca oraz na ustawieniu odpowiedniej komendy
w programie Cron. Służy on do ustalania harmonogramu wykonywania danych zadań, przykładowo do
co tygodniowego wykonania uzupełnienia magazynu. Ostatnim krokiem w implementacji projektu była
implementacja zabezpieczeń bazy danych przed jednoczesnym zapisem użytkowników do tabel.
Zabezpieczenie jest o tyle istotne, ponieważ zakładamy w naszym projekcie wielu administratorów/
realizatorów zamówień.

\subsection{System automatycznego zamawiania}

\subsection{Zabezpieczenie operacji na bazie danych w przypadku wielu użytkowników}
W celu zabezpieczenia bazy danych przed jednoczesnymn zapisem przez wielu
użytkowników wymaga wpierw identyfikacja miejsc w których do takiej sytuacji
może dojść. Operacje dodawania danych do tabel są domyślnie obsługiwane przez
bazę danych Oracle poprzez stosowanie ekskluzywnej blokady rekordu - oznacza to,
że inne operacje wykonywane na tej samej tabeli nie mogą zablokować jej na
wyłączność. Taka operacja w połączeniu z uzyskiwaniem klucza głównego z
sekwencji utworzonej w bazie danych pozwala na dodawanie wielu produktów w tym
samym czasie.

Jednym z miejsc, w których wymagana jest większa kontrola nad dostępem do bazy
danych przez poszczególnych użytkowników jest moment wydawania gotowych
zamówień. Taka procedura składa się z następujących kroków:
\begin{enumerate}
   \item Sprawdzenie czy na magazynie znajduje się wystarczająca ilość detali
         (wyrażenie ``SELECT ...''),
         \begin{enumerate}
            \item Jeśli produktów jest za mało, wyświetlamy komunikat o błędzie, i nie
                  zmieniamy nic w bazie danych,
            \item Jeśli produktów jest wystarczająca ilość, przechodzimy do kroku 2.
         \end{enumerate}
   \item Blokujemy dostęp do tabel w trybie ekskluzywnym (Jeśli nikt inny tego wcześniej nie zrobił),
   \item Wywołujemy procedurę ``COMPLETE\_ORDER'' która pomniejsza stany
         magazynowe poszczególnych detali o wymaganą ilość, przenosi zamówienie do
         tabeli historycznych zamówień oraz usuwa z magazynu wszystkie produkty,
         których ilość jest równa 0.
   \item Zwalniamy ekskluzywną blokadę na tabelach
\end{enumerate}
Poniżej przedstawione są dwie procedury, które korzystają z blokowania tabel w
celu wykonania operacji UPDATE oraz DELETE
\begin{lstlisting}[language=sql, frame=single,tabsize=1,breaklines=true,caption={Procedura COMPLETE\_ORDER}]
   PROCEDURE "COMPLETE_ORDER" (
  "ORDER_INVOICE_ID" IN NUMBER) AS

BEGIN 
	LOCK TABLE STOCK IN EXCLUSIVE MODE;
	FOR i in (Select PRODUCT_ID,PRODUCT_QUANTITY From INVOICE_ITEMS Where Invoice_ID=ORDER_INVOICE_ID) LOOP
		FOR j in (Select DETAIL_ID,DETAIL_QUANTITY From PROD_SPECIFICATION Where PRODUCT_ID = i.product_id) LOOP
			UPDATE STOCK SET QUANTITY = QUANTITY - (i.product_quantity*j.detail_quantity) Where DETAIL_ID=j.detail_id;
		END LOOP;
	END LOOP;
    ARCHIVE_INVOICE(ORDER_INVOICE_ID);
	DELETE FROM STOCK WHERE QUANTITY = 0;
	COMMIT;
END;
\end{lstlisting}
\begin{lstlisting}[language=sql, frame=single,tabsize=1,breaklines=true, caption={Procedura ARCHIVE\_INVOICE}]
   PROCEDURE "ARCHIVE_INVOICE" (
   "OLD_INVOICE_ID" IN NUMBER ) AS 
BEGIN
  LOCK TABLE INVOICES, HISTORICAL_INVOICES IN EXCLUSIVE MODE;
  INSERT INTO historical_invoices SELECT * FROM INVOICES WHERE invoices.invoice_id = OLD_INVOICE_ID;
  DELETE FROM INVOICES WHERE invoices.invoice_id = OLD_INVOICE_ID;
  COMMIT;
END ARCHIVE_INVOICE;
\end{lstlisting}
\begin{lstlisting}[language=C, frame=single,tabsize=1,caption={Kod aplikacji wywołujący procedurę COMPLETE\_ORDER}]
if (IsEnoughToComplete)
   {
      using (var connection = m_context.Database.GetDbConnection())
      {
         connection.Open();
         var cmd = connection.CreateCommand() as OracleCommand;
         cmd.CommandText = "COMPLETE_ORDER";
         cmd.CommandType = System.Data.CommandType.StoredProcedure;
         OracleParameter param1 = new OracleParameter("ORDER_INVOICE_ID", InvoiceID);
         cmd.Parameters.Add(param1);
         cmd.ExecuteNonQuery();
         connection.Close();
      }
   }
try
   m_context.SaveChanges();
catch
   IsEnoughToComplete = false;
\end{lstlisting}

Dodatkowe zabezpieczenie zostało zaimplementowane na poziome samej aplikacji. W
klasie odpowiedzialnej za dostęp do bazy danych dodane zostało publiczne pole
statyczne \textit{IsCompletingOrder}, które jest sprawdzane przed wykonaniem
procedury ``COMPLTE\_ORDER''. Taka implementacja zapewnia ochronę przed
niepoprawnym zapisem danych na poziome samej aplikacji jak i również bazy
danych. Implementacja pola statycznego pozwala również na uniknięcie sytuacji
dead-lock.
\begin{lstlisting}[language=C,frame=single]
while (ModelContext.IsCompletingOrder)
{
   Thread.Sleep(20);
   counter++;
   if (counter == 10)
   {
      isTimeout=true;
      break;
   }
}
\end{lstlisting}

\section{Testowanie}
\subsection{Testowanie procedur w bazie danych}
Testowanie procedur zostało przeprowadzone wprost z konsoli. Procedura
archiwizacji jest wywoływana wprost z procedury kompletowania i kończenia
zamówienia, dlatego były one testowe jednocześnie. Wywołanie odbyło się przez
komendę:
\begin{lstlisting}[language=sql]
   EXECUTE COMPLETE_ORDER(33);
\end{lstlisting}
Zgodnie z założeniami, stany magazynowe zostało pomniejszone o odpowiednią ilość
detali, oraz samo zamówienie zostało przeniesione do tabeli zamówień
historycznych.

\subsection{Testowanie interfejsu użytkownika}
Testowanie interfejsu zamawiania produktów rozpoczęliśmy od sprawdzenia
walidacji wszystkich pól, które muszą zostać wypełnione przez użytkownika.
Pozwoliło to wyeliminować wszelkie błędy związane z niepoprawnie wprowadzonymi
danymi.

\subsubsection{Strona ``Produkty'' oraz dodawanie produktów do koszyka}
Pole
ilości zamawianych produktów musi zawierać tylko liczby większe od 0, co
przetestowaliśmy próbując wpisać wartości ujemne lub litery i znaki. Taka
walidacja jest przeprowadzana zarówno po stronie klienta, jak i serwera. W razie
przekazania w formularzu ilości produktów mniejszej od 0 lub w innej postaci, to
polecenie nie jest wykonywane.

\subsubsection{Koszyk}
Następną testowaną funkcjonalnością był koszyk, z którego bezprośrednio składamy
zamówienia. Wymagana jest walidacja dwóch rzeczy:
\begin{itemize}
   \item W koszyku znajduje się conajmniej jeden produkt,
   \item Pole ``Zamawiający'' nie jest puste.
\end{itemize}
W przypadku gdy koszyk jest pusty, przycisk ``Zamów'' jest nieaktywny co pozwoliło
zabezpieczyć przed potencjalnie pustymi zamówieniami. Pole ``Zamawiający'' zostało
oznaczone jako \textit{required}, co sprawiło że strona nie może zostać zatwierdzona
tak długo dopóki w formularzu nie zostanie uzupełnione pole ``Zamawiający''. W przypadku
ingerencji w kod strony, to samo sprawdzenie wykonywane jest po stronie serwera
przed ostatecznym złożeniem zamówienia. W przypadku gdy któreś sprawdzenie
walidacyjne nie zostanie potwierdzone, następuje natychmiastowe porzucenie
aktualnego koszyka oraz przeniesienie do strony głównej.

\subsubsection{Zamawianie części zamiennych przez administratorów}
Ostatnim miejscem, w którym należało przeprowadzać walidację wprowadzanych
danych jest panel domawiania części przez administratorów aby uzupełnić stany
magazynowe. Typ zamawianego produktu jest wybierany z rozwijanej listy
dostępnych produktów, co pozwala uniknąć walidacji tego pola ze względu na brak
możliwości przekazania innych danych. Pole ilości zamawianych części musi
zawierać liczbę większą od 0. Oznacza to że nie mogą się tam znaleźć żadne
litery ani znaki. Walidacja w tym wypadku również jest przeprowadzana po stronie
klienta, w postaci ograniczeń wartości wpisywanych do pola oraz po stronie
serwera już po przesłaniu formularza.

\subsection{Testowanie funkcjonalności systemu automatycznego zamawiania}

\subsection{Testowanie dostępu wielu osób jednocześnie}
W celu przetestowania dostępu wielu osób do bazy danych jednocześnie
skorzystaliśmy z narzędzia
dostępnego na stronie \textit{loader.io}. Pozwala ono na testowanie odpowiedzi
serwerów pod różnyn obciążeniem. Testy zostały przeprowadzone na stronie z
produktami, w taki sposób aby każde zapytanie wyszukiwało produkty w bazie
danych po ich nazwie. Wymagało to odpowiedzi ze strony bazy danych do każdego
zapytania. Testy zostały przeprowadzone od 10 do 100 zapytań jednocześnie na
przestrzeni 1 minuty. Wszystkie odpowiedzi były poprawne.

\section{Prezentacja ostatecznego wyglądu aplikacji}
\subsection{Widok zwykłego użytkownika}

\subsubsection{Strona główna}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/powitanie_uzytkownik.png}
   \caption{Strona główna - strona powitania}
\end{figure}
Strona główna przedstawia widok, jaki widzimy zaraz po wejściu na stronę www naszego projektu.
Na stronie widnieje powitanie. Poruszanie się po stronie zapewnione jest przez nas za pomocą paska
nawigacyjnego. Numerem jeden w niebieskiej obramówce oznaczone jest miejsce nawigacji pomiędzy
poszczególnymi stronami. Pod numerem dwa znajduje się przycisk przejścia do strony z koszykiem.
Numer 3 jest przyciskiem logowania do panelu administratora.
\subsubsection{Produkty}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.7\textwidth,frame]{Wyglad/produkty.png}
   \caption{Przegląd dostępnych produktów}
\end{figure}
\begin{figure}[h]
   \centering
   \includegraphics[width=0.4\textwidth,frame]{Wyglad/dodaj_koszyk.png}
   \caption{Okno dodawania produktu do koszyka}
\end{figure}
Strona pozwalająca na przeglądanie produktów dostępnych do zakupu stanowi
kluczową część naszego projektu. Potencjalni klienci mogą oglądać jakie produkty
są dostępne do zamówienia oraz dodać je do koszyka z tego samego miejsca.
Dodawanie do koszyka odbywa się na tej samej stronie, za pomocą okna modalnego,
w którym możemy wybrać ilość produktów którą chcemy dodać do koszyka.

\subsubsection{Koszyk}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/koszyk_uzytkownik.png}
   \caption{Koszyk}
\end{figure}
Powyższe zdjęcie przedstawia stronę z zawartością koszyka. Składa się ona z kilku elemenetów:
\begin{enumerate}
   \item Nazwa produktu - nazwa zamówionego przez użytkownika produktu.
   \item Pole z zamówioną ilością.
   \item Przycisk do usuwania produktu z zamówienia.
   \item Pole Zamawiający - pole do wpisania informacji o zamawiającym.
   \item Przycisk zamów - przycisk potwierdzenia zamówienia. Po wciśnięciu tego przycisku następuje
         przejście do strony potwierdzenia z informacją o zamówionych produktach.
\end{enumerate}

\subsubsection{Potwierdzenie zamówienia}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/zlozenie_zamowienia_uzytkownik.png}
   \caption{Strona zawierająca potwierdzenie zamówienia}
\end{figure}
Na powyższym zdjęciu przedstawiona jest zawartość strony potwierdzającej zamówienie produktów. W
pomarańczowej ramce przedstawiona jest lista zamówionych produktów.

\subsection{Widok administratora}
\subsubsection{Zaloguj}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/logowanie_admin.png}
   \caption{Panel logowania do widoku administratora}
\end{figure}
W miejsce ``Nazwa użytkownika'' oraz ``Hasło'' administrator musi podać prawidłowe dane. Po uzupełnieniu
danych i naciśnięciu przycisku ``Zaloguj się'' następuje przekierowanie do pełnego widoku administratora.

\subsubsection{Strona główna}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/powitanie_admin.png}
   \caption{Strona główna widoku administratora}
\end{figure}
Widok ten zostaje wyświetlony tuż po zalogowaniu. Jest to widok rozszerzony w stosunku do widoku
zwykłego użytkownika. Poruszanie się również zapewnione jest poprzez pasek nawigacyjny. Dodatkowe
funkcje/widoki, przyznane administratorowi opisane będą w następnych punktach.

\subsubsection{Produkty}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth,frame]{Wyglad/produkty_admin.png}
   \caption{Widok strony podglądu produktów w układzie administratora}
\end{figure}
Strona wyświetlająca produkty w widoku administrora jest bardzo podobna do
zwykłego podglądu - różnicą jest przycisk znajdujący się pod każdym produktem,
który w przypadku administratora przekieruje nas na stronę specyfikacji
produktu.

\subsubsection{Specyfikacja produktu}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.8\textwidth,frame]{Wyglad/spec.png}
   \caption{Podgląd specyfikacji pojedynczego produktu}
\end{figure}
Strona wyświetlająca specyfikację produktu pozwala sprawdzić jakie części są
wymagane dla danego produktu.

\subsubsection{Przeglądaj zamówienia}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/lista_zamowien_admin.png}
   \caption{Strona zapewniająca podgląd listy złożonych zamówień}
\end{figure}
Widok tej strony pojawia się po wciśnięciu odpowiedniego przycisku w pasku nawigacyjnym.
Administrator ma tutaj dostęp do listy złożonych zamówień. Oprócz tego może podejrzeć szczegóły
każdego zamówienia naciskając przycisk ``Szczegóły zamówienia''. Dodatkowo wyposażyliśmy
administratora w możliwość usuwania złożonego zamówienia oraz możliwość realizacji zamówienia.
Naciskając niebieski tekst ``Usuń zamówienie'' spowodujemy usunięcie konkretnego zamówienia z bazy
danych. Naciśnięcie przycisku ``Zrealizuj zamówienie'' powoduje wywołanie
procedury sprawdzającej wymagany stan magazynowy, i w przypadku wystarczających
ilości są one usuwane z magazynu a samo zamówienie jest przenoszone do tabeli
zamówień historycznych.

\begin{itemize}
   \item Panel ``Szczegóły zamówienia''\\
         \newline
         \fbox{
            \parbox[c]{0.92\textwidth}{
               \centering
               \includegraphics[width=0.6\textwidth]{Wyglad/szczegoly_zam1_admin.png}
               \includegraphics[width=0.6\textwidth]{Wyglad/szczegoly_zam2_admin.png}
            }}
         \captionof{figure}{Szczegóły pojedynczego zamówienia}
         W panelu ze szczegółami zamówienia administrator może podejrzeć ilości zamówionych produktów.
         Oprócz tego wyświetlana jest lista wszystkich wymaganych części do konkretnego zamówienia w
         zestawieniu z ilością dostępnych części na magazynie.
\end{itemize}

\subsubsection{Zamów części dodatkowe}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/czesci_dodatkowe_admin.png}
   \caption{Widok strony pozwalającej na ręczne zamawianie części do magazynu}
\end{figure}
Panel ten składa się z kilku elementów:
\begin{enumerate}
   \item Rozwijana lista - lista wyboru części do zamówienia
   \item Okno ilości - pole pozwalające wpisać ilość produktu do zamówienia
   \item Przyciski dodawania lub odejmowania kolejnych części. Po wciśnięciu przycisku ``+''
         dodajemy kolejne pole dla kolejnej części. Po wciśnięciu przycisku ``-'' zmniejszamy ilość
         rozwijanych list z której wcześniej wybraliśmy produkt.
   \item Przycisk ``Zamów''. Po wciśnięciu przycisku produkty zostają zamówione do magazynu i
         następuje automatyczne przekierowanie na stronę ``Stany magazynowe''.
\end{enumerate}

\subsubsection{Stany magazynowy}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/magazyn_admin.png}
   \caption{Widok strony przedstawiającej zawartość magazynu producenta przedmiotów}
\end{figure}

\subsubsection{Wyloguj}
\begin{figure}[H]
   \centering
   \includegraphics[width=0.99\textwidth,frame]{Wyglad/wylogowanie_admin.png}
   \caption{Widok strony po wciśnięciu przycisku ``Wyloguj'' w pasku nawigacyjnym}
\end{figure}

\end{document}